/* tslint:disable */
/* eslint-disable */
/*
Kenjo API

Before starting to use the Kenjo API, you have to request the API activation for a sandbox or production environment to the Kenjo Customer Success team. After that, an admin user has to go to *Settings > Integrations > API keys*, to generate the **API Key**. Follow the steps described in the **Autentication section** of this document. <br>The API key is needed to request the bearer token. Each endpoint callout requires a valid bearer token in the Authorization header. Once the token is retrieved, it will be useful during the time limit indicated by the 'expiration date'.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AuthenticationCreateBearerToken400Response } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequest } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestAccount } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestAddress } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestFinancial } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestHome } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestPersonal } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestWork } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeRequestWorkSchedule } from '../models';
// @ts-ignore
import { EmployeesCreateInactiveEmployeeResponse } from '../models';
// @ts-ignore
import { EmployeesGetAccountsResponse } from '../models';
// @ts-ignore
import { EmployeesGetEmployeeInformationResponse } from '../models';
// @ts-ignore
import { EmployeesGetListResponse } from '../models';
// @ts-ignore
import { EmployeesGetWorkSchedulesResponse } from '../models';
// @ts-ignore
import { EmployeesListAddressesResponse } from '../models';
// @ts-ignore
import { EmployeesListFinancialsResponse } from '../models';
// @ts-ignore
import { EmployeesListHomesResponse } from '../models';
// @ts-ignore
import { EmployeesListPersonalsResponse } from '../models';
// @ts-ignore
import { EmployeesListWorksResponse } from '../models';
// @ts-ignore
import { EmployeesUpdateAddressRequest } from '../models';
// @ts-ignore
import { EmployeesUpdateAddressResponse } from '../models';
// @ts-ignore
import { EmployeesUpdateEmployeeAccountsRequest } from '../models';
// @ts-ignore
import { EmployeesUpdateEmployeeAccountsResponse } from '../models';
// @ts-ignore
import { EmployeesUpdateFinancialsRequest } from '../models';
// @ts-ignore
import { EmployeesUpdateFinancialsResponse } from '../models';
// @ts-ignore
import { EmployeesUpdateHomeRequest } from '../models';
// @ts-ignore
import { EmployeesUpdateHomeResponse } from '../models';
// @ts-ignore
import { EmployeesUpdatePersonalsRequest } from '../models';
// @ts-ignore
import { EmployeesUpdatePersonalsResponse } from '../models';
// @ts-ignore
import { EmployeesUpdateWorkScheduleRequest } from '../models';
// @ts-ignore
import { EmployeesUpdateWorkScheduleResponse } from '../models';
// @ts-ignore
import { EmployeesUpdateWorksRequest } from '../models';
// @ts-ignore
import { EmployeesUpdateWorksResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * EmployeesApi - axios parameter creator
 * @export
 */
export const EmployeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint activates a Kenjo employee given by the employeeId. It sends an email to the recipient of the employee email to start the onboarding process. Once the password is filled, the employee changes to \'active\' (\'isActive\' = TRUE). While the employee is not active it is possible to send activation emails.
         * @param {string} employeeId The _id of the employee to send the activation email.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEmployee: async (employeeId: string, authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('activateEmployee', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('activateEmployee', 'authorization', authorization)
            const localVarPath = `/employees/{employeeId}/activate`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/activate',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates a deactivated employee in Kenjo, the \'isActive\' field set to false. To activate an employee use the put /activate method. This method will send an activation message to the employee email to complete the activation through the onboarding wizard. <br><br>The field *email* is required and must be unique. Also *firstName*, *lastName* and *companyId* are required fields. If the work schedule is not provided then all the days of the week except Saturdays and Sundays are set to true. If the *language* is not specified, the assigned company language will be set by default. <br><br>**Custom fields** information can be provided in this operation for the **personal**, **work**, **address**, **financial** and **home** sections. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'Activity type\' belongs to the section \'work\'*:   ``` ... {   ...     \"work\": {       \"c_Activitytype\": \"1\",       ...     },   ... } ``` *\'Activity type\' is a field type \'List\' (Strings list) with the possible values: \"1\", \"2\" and \"3\". It means that if a different value or type is provided then the request will return an error.* <br><br>If the operation get success then an inactive employee is created and the response will include the provided information and the Kenjo id for the new employee. 
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesCreateInactiveEmployeeRequest} employeesCreateInactiveEmployeeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInactiveEmployee: async (authorization: string, employeesCreateInactiveEmployeeRequest: EmployeesCreateInactiveEmployeeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createInactiveEmployee', 'authorization', authorization)
            // verify required parameter 'employeesCreateInactiveEmployeeRequest' is not null or undefined
            assertParamExists('createInactiveEmployee', 'employeesCreateInactiveEmployeeRequest', employeesCreateInactiveEmployeeRequest)
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesCreateInactiveEmployeeRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesCreateInactiveEmployeeRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deactivates a Kenjo employee given by the employeeId. It sets the isActive field to FALSE and invalidate the access Kenjo for the employee. While the employee is not active it is possible to send activation emails.
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEmployeeById: async (employeeId: string, authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('deactivateEmployeeById', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deactivateEmployeeById', 'authorization', authorization)
            const localVarPath = `/employees/{employeeId}/deactivate`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/deactivate',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **account** sections of the existing employees. The account section contains information such as *email*, *external Id*, *language* and *activation status*.
         * @param {string} authorization A valid bearer token.
         * @param {string} [email] The Kenjo email of the employee.
         * @param {'en' | 'de' | 'es'} [language] The employee language.
         * @param {string} [externalId] The external id of the employee.
         * @param {boolean} [isActive] The employee activation status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (authorization: string, email?: string, language?: 'en' | 'de' | 'es', externalId?: string, isActive?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAccounts', 'authorization', authorization)
            const localVarPath = `/employees/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['externalId'] = externalId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/accounts',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about the **account**, **personal**, **work**, **work schedule**, **address**, **financial** and **home** sections for a given employee id. The *employeeId* param represents a Kenjo employee id.
         * @param {string} authorization A valid bearer token.
         * @param {string} employeeId The _id of the employee to request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployeeInformation: async (authorization: string, employeeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getEmployeeInformation', 'authorization', authorization)
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('getEmployeeInformation', 'employeeId', employeeId)
            const localVarPath = `/employees/{employeeId}`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the list of employee accounts existing in Kenjo. It is similar to the *_/employees/accounts* endpoint.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getList', 'authorization', authorization)
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **work schedule** sections of the existing employees.
         * @param {string} authorization A valid bearer token.
         * @param {boolean} [trackAttendance] The activation status of attendance tracking for the employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkSchedules: async (authorization: string, trackAttendance?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getWorkSchedules', 'authorization', authorization)
            const localVarPath = `/employees/work-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (trackAttendance !== undefined) {
                localVarQueryParameter['trackAttendance'] = trackAttendance;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/work-schedules',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **address** sections of the existing employees.
         * @param {string} authorization A valid bearer token.
         * @param {string} [street] The name of the street.
         * @param {string} [postalCode] The postal code.
         * @param {string} [city] The city.
         * @param {string} [country] The country code in ISO 3166-1 alpha-2.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses: async (authorization: string, street?: string, postalCode?: string, city?: string, country?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listAddresses', 'authorization', authorization)
            const localVarPath = `/employees/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (street !== undefined) {
                localVarQueryParameter['street'] = street;
            }

            if (postalCode !== undefined) {
                localVarQueryParameter['postalCode'] = postalCode;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/addresses',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **financial** sections of the existing employees.
         * @param {string} authorization A valid bearer token.
         * @param {string} [accountHolderName] The accounts holder\&#39;s name.
         * @param {string} [bankName] The bank name.
         * @param {string} [accountNumber] The account number.
         * @param {string} [iban] The IBAN.
         * @param {string} [swiftCode] The SWIFT code.
         * @param {string} [nationalId] The national id document
         * @param {string} [passport] The passport number.
         * @param {string} [nationalInsuranceNumber] The national insurance number.
         * @param {string} [taxCode] The tax number.
         * @param {string} [taxIdentificationNumber] The tax identification number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials: async (authorization: string, accountHolderName?: string, bankName?: string, accountNumber?: string, iban?: string, swiftCode?: string, nationalId?: string, passport?: string, nationalInsuranceNumber?: string, taxCode?: string, taxIdentificationNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listFinancials', 'authorization', authorization)
            const localVarPath = `/employees/financials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (accountHolderName !== undefined) {
                localVarQueryParameter['accountHolderName'] = accountHolderName;
            }

            if (bankName !== undefined) {
                localVarQueryParameter['bankName'] = bankName;
            }

            if (accountNumber !== undefined) {
                localVarQueryParameter['accountNumber'] = accountNumber;
            }

            if (iban !== undefined) {
                localVarQueryParameter['iban'] = iban;
            }

            if (swiftCode !== undefined) {
                localVarQueryParameter['swiftCode'] = swiftCode;
            }

            if (nationalId !== undefined) {
                localVarQueryParameter['nationalId'] = nationalId;
            }

            if (passport !== undefined) {
                localVarQueryParameter['passport'] = passport;
            }

            if (nationalInsuranceNumber !== undefined) {
                localVarQueryParameter['nationalInsuranceNumber'] = nationalInsuranceNumber;
            }

            if (taxCode !== undefined) {
                localVarQueryParameter['taxCode'] = taxCode;
            }

            if (taxIdentificationNumber !== undefined) {
                localVarQueryParameter['taxIdentificationNumber'] = taxIdentificationNumber;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/financials',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **home** sections of the existing employees.
         * @param {string} authorization A valid bearer token.
         * @param {'Divorced' | 'Domestic Partnership' | 'Married' | 'Separated' | 'Single' | 'Widowed'} [maritalStatus] The marital status. Only is valid one of the following values \&quot;Divorced\&quot;, \&quot;Domestic Partnership\&quot;, \&quot;Married\&quot;, \&quot;Separated\&quot;, \&quot;Single\&quot;, \&quot;Widowed\&quot;.
         * @param {string} [spouseFirstName] The first name of the employee\&#39;s spouse.
         * @param {string} [spouseLastName] The last name of the employee\&#39;s spouse.
         * @param {string} [spouseBirthdate] The birth date of the employee\&#39;s spouse. Format YYYY-MM-DDThh:mm:ss.000Z.
         * @param {'Male' | 'Female' | 'Other'} [spouseGender] The employee\&#39;s spouse gender. Only is valid one of the following values \&#39;Male\&#39; (male), \&#39;Female\&#39; (female) or \&#39;Other\&#39; (other).
         * @param {string} [personalEmail] The employee personal email.
         * @param {string} [personalPhone] The employee personal phone.
         * @param {string} [personalMobile] The employee personal mobile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHomes: async (authorization: string, maritalStatus?: 'Divorced' | 'Domestic Partnership' | 'Married' | 'Separated' | 'Single' | 'Widowed', spouseFirstName?: string, spouseLastName?: string, spouseBirthdate?: string, spouseGender?: 'Male' | 'Female' | 'Other', personalEmail?: string, personalPhone?: string, personalMobile?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listHomes', 'authorization', authorization)
            const localVarPath = `/employees/homes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (maritalStatus !== undefined) {
                localVarQueryParameter['maritalStatus'] = maritalStatus;
            }

            if (spouseFirstName !== undefined) {
                localVarQueryParameter['spouseFirstName'] = spouseFirstName;
            }

            if (spouseLastName !== undefined) {
                localVarQueryParameter['spouseLastName'] = spouseLastName;
            }

            if (spouseBirthdate !== undefined) {
                localVarQueryParameter['spouseBirthdate'] = spouseBirthdate;
            }

            if (spouseGender !== undefined) {
                localVarQueryParameter['spouseGender'] = spouseGender;
            }

            if (personalEmail !== undefined) {
                localVarQueryParameter['personalEmail'] = personalEmail;
            }

            if (personalPhone !== undefined) {
                localVarQueryParameter['personalPhone'] = personalPhone;
            }

            if (personalMobile !== undefined) {
                localVarQueryParameter['personalMobile'] = personalMobile;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/homes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **personal** sections of the existing employees.
         * @param {string} authorization A valid bearer token.
         * @param {string} [firstName] The name of the Kenjo employee. This field is required.
         * @param {string} [lastName] The surname of the Kenjo employee. This field is required.
         * @param {string} [displayName] The composition of firstName and lastName of the Kenjo employee.
         * @param {'Male' | 'Female' | 'Other'} [gender] The employee gender. Only is valid one of the following values \&#39;Male\&#39; (male), \&#39;Female\&#39; (female) or \&#39;Other\&#39; (other).
         * @param {string} [birthdate] The employee birth date. Format YYYY-MM-DDThh:00:00.000Z.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonals: async (authorization: string, firstName?: string, lastName?: string, displayName?: string, gender?: 'Male' | 'Female' | 'Other', birthdate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listPersonals', 'authorization', authorization)
            const localVarPath = `/employees/personals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['displayName'] = displayName;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (birthdate !== undefined) {
                localVarQueryParameter['birthdate'] = birthdate;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/personals',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list with the **work** sections of the existing employees.
         * @param {string} authorization A valid bearer token.
         * @param {string} [companyId] The company id of the Kenjo employee.
         * @param {string} [officeId] The office id of the Kenjo employee.
         * @param {string} [departmentId] The department id of the Kenjo employee.
         * @param {string} [startDate] The starting date of the Kenjo employee in format YYYY-MM-DDThh:mm:ss.
         * @param {string} [jobTitle] The job title of the employee.
         * @param {string} [workPhone] The work phone of the employee.
         * @param {string} [workMobile] The work mobile of the employee.
         * @param {boolean} [isAssistant] Allow to indicate if the employee has or not the assistant role.
         * @param {string} [probationPeriodEnd] The probation period of the employee. Format YYYY-MM-DDThh:mm:ss.000Z.
         * @param {string} [reportsToId] The Kenjo employee id of the user to whom the employee reports. The employee id to assign can be an active or inactive user. Trying to assign the own employee id or the id of someone who is already reporting will arise an error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorks: async (authorization: string, companyId?: string, officeId?: string, departmentId?: string, startDate?: string, jobTitle?: string, workPhone?: string, workMobile?: string, isAssistant?: boolean, probationPeriodEnd?: string, reportsToId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listWorks', 'authorization', authorization)
            const localVarPath = `/employees/works`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (officeId !== undefined) {
                localVarQueryParameter['officeId'] = officeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (jobTitle !== undefined) {
                localVarQueryParameter['jobTitle'] = jobTitle;
            }

            if (workPhone !== undefined) {
                localVarQueryParameter['workPhone'] = workPhone;
            }

            if (workMobile !== undefined) {
                localVarQueryParameter['workMobile'] = workMobile;
            }

            if (isAssistant !== undefined) {
                localVarQueryParameter['isAssistant'] = isAssistant;
            }

            if (probationPeriodEnd !== undefined) {
                localVarQueryParameter['probationPeriodEnd'] = probationPeriodEnd;
            }

            if (reportsToId !== undefined) {
                localVarQueryParameter['reportsToId'] = reportsToId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/works',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **address** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'province\' belongs to the \'address\' section*:   ```   {     ...,     \"country\": \"ES\",     \"c_province\": \"MD\",     ...   } ``` *\'province\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdateAddressRequest} employeesUpdateAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddress: async (employeeId: string, authorization: string, employeesUpdateAddressRequest: EmployeesUpdateAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updateAddress', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateAddress', 'authorization', authorization)
            // verify required parameter 'employeesUpdateAddressRequest' is not null or undefined
            assertParamExists('updateAddress', 'employeesUpdateAddressRequest', employeesUpdateAddressRequest)
            const localVarPath = `/employees/{employeeId}/addresses`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdateAddressRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/addresses',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdateAddressRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **account** section for a given employee id. The operation only updates the fields provided in the body.
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdateEmployeeAccountsRequest} employeesUpdateEmployeeAccountsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployeeAccounts: async (employeeId: string, authorization: string, employeesUpdateEmployeeAccountsRequest: EmployeesUpdateEmployeeAccountsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updateEmployeeAccounts', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateEmployeeAccounts', 'authorization', authorization)
            // verify required parameter 'employeesUpdateEmployeeAccountsRequest' is not null or undefined
            assertParamExists('updateEmployeeAccounts', 'employeesUpdateEmployeeAccountsRequest', employeesUpdateEmployeeAccountsRequest)
            const localVarPath = `/employees/{employeeId}/accounts`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdateEmployeeAccountsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/accounts',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdateEmployeeAccountsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **financial** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'special tax\' belongs to the \'financial\' section*:   ```   {     ...,     \"iban\": \"ES2345123456789077\",     \"c_specialtax\": 1500,     ...   } ``` *\'special tax\' is a field type \'Number\'. It means that if a different type of data (string or boolean) is provided then the request will return an error.* 
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdateFinancialsRequest} employeesUpdateFinancialsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFinancials: async (employeeId: string, authorization: string, employeesUpdateFinancialsRequest: EmployeesUpdateFinancialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updateFinancials', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateFinancials', 'authorization', authorization)
            // verify required parameter 'employeesUpdateFinancialsRequest' is not null or undefined
            assertParamExists('updateFinancials', 'employeesUpdateFinancialsRequest', employeesUpdateFinancialsRequest)
            const localVarPath = `/employees/{employeeId}/financials`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdateFinancialsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/financials',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdateFinancialsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **home** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'pet name\' belongs to the \'home\' section*:   ```   {     ...,     \"maritalStatus\": \"Divorced\",     \"c_petname\": \"Boliche\",     ...   } ``` *\'pet name\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdateHomeRequest} employeesUpdateHomeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHome: async (employeeId: string, authorization: string, employeesUpdateHomeRequest: EmployeesUpdateHomeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updateHome', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateHome', 'authorization', authorization)
            // verify required parameter 'employeesUpdateHomeRequest' is not null or undefined
            assertParamExists('updateHome', 'employeesUpdateHomeRequest', employeesUpdateHomeRequest)
            const localVarPath = `/employees/{employeeId}/homes`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdateHomeRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/homes',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdateHomeRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **personal** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'category\' belongs to the \'personal\' section*:   ```   {     ...,     \"lastName\": \"Nadie\",     \"c_category\": \"Good\",     ...   } ``` *\'category\' is a field type \'List\' (Strings list) with the possible values: \"Good\" and \"Bad\". It means that if a different value or type is provided then the request will return an error.* 
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdatePersonalsRequest} employeesUpdatePersonalsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonals: async (employeeId: string, authorization: string, employeesUpdatePersonalsRequest: EmployeesUpdatePersonalsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updatePersonals', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updatePersonals', 'authorization', authorization)
            // verify required parameter 'employeesUpdatePersonalsRequest' is not null or undefined
            assertParamExists('updatePersonals', 'employeesUpdatePersonalsRequest', employeesUpdatePersonalsRequest)
            const localVarPath = `/employees/{employeeId}/personals`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdatePersonalsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/personals',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdatePersonalsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **work schedule** section for a given employee id. The operation only updates the fields provided in the body.
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdateWorkScheduleRequest} employeesUpdateWorkScheduleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkSchedule: async (employeeId: string, authorization: string, employeesUpdateWorkScheduleRequest: EmployeesUpdateWorkScheduleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updateWorkSchedule', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateWorkSchedule', 'authorization', authorization)
            // verify required parameter 'employeesUpdateWorkScheduleRequest' is not null or undefined
            assertParamExists('updateWorkSchedule', 'employeesUpdateWorkScheduleRequest', employeesUpdateWorkScheduleRequest)
            const localVarPath = `/employees/{employeeId}/work-schedules`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdateWorkScheduleRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/work-schedules',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdateWorkScheduleRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the employee **work** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'activity type\' belongs to the \'personal\' section*:   ```   {     ...,     \"companyId\": \"61d874aef37c05cfba4f1b38\",     \"c_activityType\": \"1\",     ...   } ``` *\'activity Type\' is a field type \'List\' (Strings list) with the possible values: \"1\" and \"2\". It means that if a different value or type is provided then the request will return an error.* 
         * @param {string} employeeId The _id of the employee to update.
         * @param {string} authorization A valid bearer token.
         * @param {EmployeesUpdateWorksRequest} employeesUpdateWorksRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorks: async (employeeId: string, authorization: string, employeesUpdateWorksRequest: EmployeesUpdateWorksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('updateWorks', 'employeeId', employeeId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateWorks', 'authorization', authorization)
            // verify required parameter 'employeesUpdateWorksRequest' is not null or undefined
            assertParamExists('updateWorks', 'employeesUpdateWorksRequest', employeesUpdateWorksRequest)
            const localVarPath = `/employees/{employeeId}/works`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId !== undefined ? employeeId : `-employeeId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: employeesUpdateWorksRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/employees/{employeeId}/works',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(employeesUpdateWorksRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeesApi - functional programming interface
 * @export
 */
export const EmployeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint activates a Kenjo employee given by the employeeId. It sends an email to the recipient of the employee email to start the onboarding process. Once the password is filled, the employee changes to \'active\' (\'isActive\' = TRUE). While the employee is not active it is possible to send activation emails.
         * @param {EmployeesApiActivateEmployeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateEmployee(requestParameters: EmployeesApiActivateEmployeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateEmployee(requestParameters.employeeId, requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint creates a deactivated employee in Kenjo, the \'isActive\' field set to false. To activate an employee use the put /activate method. This method will send an activation message to the employee email to complete the activation through the onboarding wizard. <br><br>The field *email* is required and must be unique. Also *firstName*, *lastName* and *companyId* are required fields. If the work schedule is not provided then all the days of the week except Saturdays and Sundays are set to true. If the *language* is not specified, the assigned company language will be set by default. <br><br>**Custom fields** information can be provided in this operation for the **personal**, **work**, **address**, **financial** and **home** sections. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'Activity type\' belongs to the section \'work\'*:   ``` ... {   ...     \"work\": {       \"c_Activitytype\": \"1\",       ...     },   ... } ``` *\'Activity type\' is a field type \'List\' (Strings list) with the possible values: \"1\", \"2\" and \"3\". It means that if a different value or type is provided then the request will return an error.* <br><br>If the operation get success then an inactive employee is created and the response will include the provided information and the Kenjo id for the new employee. 
         * @param {EmployeesApiCreateInactiveEmployeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInactiveEmployee(requestParameters: EmployeesApiCreateInactiveEmployeeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesCreateInactiveEmployeeResponse>> {
            const employeesCreateInactiveEmployeeRequest: EmployeesCreateInactiveEmployeeRequest = {
                account: requestParameters.account,
                personal: requestParameters.personal,
                work: requestParameters.work,
                workSchedule: requestParameters.workSchedule,
                address: requestParameters.address,
                financial: requestParameters.financial,
                home: requestParameters.home
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInactiveEmployee(requestParameters.authorization, employeesCreateInactiveEmployeeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deactivates a Kenjo employee given by the employeeId. It sets the isActive field to FALSE and invalidate the access Kenjo for the employee. While the employee is not active it is possible to send activation emails.
         * @param {EmployeesApiDeactivateEmployeeByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateEmployeeById(requestParameters: EmployeesApiDeactivateEmployeeByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateEmployeeById(requestParameters.employeeId, requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **account** sections of the existing employees. The account section contains information such as *email*, *external Id*, *language* and *activation status*.
         * @param {EmployeesApiGetAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(requestParameters: EmployeesApiGetAccountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesGetAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(requestParameters.authorization, requestParameters.email, requestParameters.language, requestParameters.externalId, requestParameters.isActive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about the **account**, **personal**, **work**, **work schedule**, **address**, **financial** and **home** sections for a given employee id. The *employeeId* param represents a Kenjo employee id.
         * @param {EmployeesApiGetEmployeeInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployeeInformation(requestParameters: EmployeesApiGetEmployeeInformationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesGetEmployeeInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployeeInformation(requestParameters.authorization, requestParameters.employeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the list of employee accounts existing in Kenjo. It is similar to the *_/employees/accounts* endpoint.
         * @param {EmployeesApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(requestParameters: EmployeesApiGetListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesGetListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **work schedule** sections of the existing employees.
         * @param {EmployeesApiGetWorkSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkSchedules(requestParameters: EmployeesApiGetWorkSchedulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesGetWorkSchedulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkSchedules(requestParameters.authorization, requestParameters.trackAttendance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **address** sections of the existing employees.
         * @param {EmployeesApiListAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddresses(requestParameters: EmployeesApiListAddressesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesListAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(requestParameters.authorization, requestParameters.street, requestParameters.postalCode, requestParameters.city, requestParameters.country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **financial** sections of the existing employees.
         * @param {EmployeesApiListFinancialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFinancials(requestParameters: EmployeesApiListFinancialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesListFinancialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFinancials(requestParameters.authorization, requestParameters.accountHolderName, requestParameters.bankName, requestParameters.accountNumber, requestParameters.iban, requestParameters.swiftCode, requestParameters.nationalId, requestParameters.passport, requestParameters.nationalInsuranceNumber, requestParameters.taxCode, requestParameters.taxIdentificationNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **home** sections of the existing employees.
         * @param {EmployeesApiListHomesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHomes(requestParameters: EmployeesApiListHomesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesListHomesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHomes(requestParameters.authorization, requestParameters.maritalStatus, requestParameters.spouseFirstName, requestParameters.spouseLastName, requestParameters.spouseBirthdate, requestParameters.spouseGender, requestParameters.personalEmail, requestParameters.personalPhone, requestParameters.personalMobile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **personal** sections of the existing employees.
         * @param {EmployeesApiListPersonalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonals(requestParameters: EmployeesApiListPersonalsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesListPersonalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonals(requestParameters.authorization, requestParameters.firstName, requestParameters.lastName, requestParameters.displayName, requestParameters.gender, requestParameters.birthdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list with the **work** sections of the existing employees.
         * @param {EmployeesApiListWorksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorks(requestParameters: EmployeesApiListWorksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesListWorksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorks(requestParameters.authorization, requestParameters.companyId, requestParameters.officeId, requestParameters.departmentId, requestParameters.startDate, requestParameters.jobTitle, requestParameters.workPhone, requestParameters.workMobile, requestParameters.isAssistant, requestParameters.probationPeriodEnd, requestParameters.reportsToId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **address** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'province\' belongs to the \'address\' section*:   ```   {     ...,     \"country\": \"ES\",     \"c_province\": \"MD\",     ...   } ``` *\'province\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddress(requestParameters: EmployeesApiUpdateAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdateAddressResponse>> {
            const employeesUpdateAddressRequest: EmployeesUpdateAddressRequest = {
                street: requestParameters.street,
                postalCode: requestParameters.postalCode,
                city: requestParameters.city,
                country: requestParameters.country
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddress(requestParameters.employeeId, requestParameters.authorization, employeesUpdateAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **account** section for a given employee id. The operation only updates the fields provided in the body.
         * @param {EmployeesApiUpdateEmployeeAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmployeeAccounts(requestParameters: EmployeesApiUpdateEmployeeAccountsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdateEmployeeAccountsResponse>> {
            const employeesUpdateEmployeeAccountsRequest: EmployeesUpdateEmployeeAccountsRequest = {
                email: requestParameters.email,
                externalId: requestParameters.externalId,
                language: requestParameters.language
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmployeeAccounts(requestParameters.employeeId, requestParameters.authorization, employeesUpdateEmployeeAccountsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **financial** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'special tax\' belongs to the \'financial\' section*:   ```   {     ...,     \"iban\": \"ES2345123456789077\",     \"c_specialtax\": 1500,     ...   } ``` *\'special tax\' is a field type \'Number\'. It means that if a different type of data (string or boolean) is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateFinancialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFinancials(requestParameters: EmployeesApiUpdateFinancialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdateFinancialsResponse>> {
            const employeesUpdateFinancialsRequest: EmployeesUpdateFinancialsRequest = {
                accountHolderName: requestParameters.accountHolderName,
                bankName: requestParameters.bankName,
                accountNumber: requestParameters.accountNumber,
                iban: requestParameters.iban,
                swiftCode: requestParameters.swiftCode,
                nationalId: requestParameters.nationalId,
                passport: requestParameters.passport,
                nationalInsuranceNumber: requestParameters.nationalInsuranceNumber,
                taxCode: requestParameters.taxCode,
                taxIdentificationNumber: requestParameters.taxIdentificationNumber
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFinancials(requestParameters.employeeId, requestParameters.authorization, employeesUpdateFinancialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **home** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'pet name\' belongs to the \'home\' section*:   ```   {     ...,     \"maritalStatus\": \"Divorced\",     \"c_petname\": \"Boliche\",     ...   } ``` *\'pet name\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateHomeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHome(requestParameters: EmployeesApiUpdateHomeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdateHomeResponse>> {
            const employeesUpdateHomeRequest: EmployeesUpdateHomeRequest = {
                maritalStatus: requestParameters.maritalStatus,
                spouseFirstName: requestParameters.spouseFirstName,
                spouseLastName: requestParameters.spouseLastName,
                spouseBirthdate: requestParameters.spouseBirthdate,
                spouseGender: requestParameters.spouseGender,
                personalEmail: requestParameters.personalEmail,
                personalPhone: requestParameters.personalPhone,
                personalMobile: requestParameters.personalMobile
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHome(requestParameters.employeeId, requestParameters.authorization, employeesUpdateHomeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **personal** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'category\' belongs to the \'personal\' section*:   ```   {     ...,     \"lastName\": \"Nadie\",     \"c_category\": \"Good\",     ...   } ``` *\'category\' is a field type \'List\' (Strings list) with the possible values: \"Good\" and \"Bad\". It means that if a different value or type is provided then the request will return an error.* 
         * @param {EmployeesApiUpdatePersonalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersonals(requestParameters: EmployeesApiUpdatePersonalsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdatePersonalsResponse>> {
            const employeesUpdatePersonalsRequest: EmployeesUpdatePersonalsRequest = {
                firstName: requestParameters.firstName,
                lastName: requestParameters.lastName,
                displayName: requestParameters.displayName,
                gender: requestParameters.gender,
                birthdate: requestParameters.birthdate
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersonals(requestParameters.employeeId, requestParameters.authorization, employeesUpdatePersonalsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **work schedule** section for a given employee id. The operation only updates the fields provided in the body.
         * @param {EmployeesApiUpdateWorkScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkSchedule(requestParameters: EmployeesApiUpdateWorkScheduleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdateWorkScheduleResponse>> {
            const employeesUpdateWorkScheduleRequest: EmployeesUpdateWorkScheduleRequest = {
                mondayWorkingDay: requestParameters.mondayWorkingDay,
                tuesdayWorkingDay: requestParameters.tuesdayWorkingDay,
                wednesdayWorkingDay: requestParameters.wednesdayWorkingDay,
                thursdayWorkingDay: requestParameters.thursdayWorkingDay,
                fridayWorkingDay: requestParameters.fridayWorkingDay,
                saturdayWorkingDay: requestParameters.saturdayWorkingDay,
                sundayWorkingDay: requestParameters.sundayWorkingDay
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkSchedule(requestParameters.employeeId, requestParameters.authorization, employeesUpdateWorkScheduleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the employee **work** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'activity type\' belongs to the \'personal\' section*:   ```   {     ...,     \"companyId\": \"61d874aef37c05cfba4f1b38\",     \"c_activityType\": \"1\",     ...   } ``` *\'activity Type\' is a field type \'List\' (Strings list) with the possible values: \"1\" and \"2\". It means that if a different value or type is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateWorksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorks(requestParameters: EmployeesApiUpdateWorksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesUpdateWorksResponse>> {
            const employeesUpdateWorksRequest: EmployeesUpdateWorksRequest = {
                companyId: requestParameters.companyId,
                officeId: requestParameters.officeId,
                departmentId: requestParameters.departmentId,
                startDate: requestParameters.startDate,
                jobTitle: requestParameters.jobTitle,
                workPhone: requestParameters.workPhone,
                workMobile: requestParameters.workMobile,
                isAssistant: requestParameters.isAssistant,
                probationPeriodEnd: requestParameters.probationPeriodEnd,
                reportsToId: requestParameters.reportsToId
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorks(requestParameters.employeeId, requestParameters.authorization, employeesUpdateWorksRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmployeesApi - factory interface
 * @export
 */
export const EmployeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeesApiFp(configuration)
    return {
        /**
         * This endpoint activates a Kenjo employee given by the employeeId. It sends an email to the recipient of the employee email to start the onboarding process. Once the password is filled, the employee changes to \'active\' (\'isActive\' = TRUE). While the employee is not active it is possible to send activation emails.
         * @param {EmployeesApiActivateEmployeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateEmployee(requestParameters: EmployeesApiActivateEmployeeRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.activateEmployee(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates a deactivated employee in Kenjo, the \'isActive\' field set to false. To activate an employee use the put /activate method. This method will send an activation message to the employee email to complete the activation through the onboarding wizard. <br><br>The field *email* is required and must be unique. Also *firstName*, *lastName* and *companyId* are required fields. If the work schedule is not provided then all the days of the week except Saturdays and Sundays are set to true. If the *language* is not specified, the assigned company language will be set by default. <br><br>**Custom fields** information can be provided in this operation for the **personal**, **work**, **address**, **financial** and **home** sections. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'Activity type\' belongs to the section \'work\'*:   ``` ... {   ...     \"work\": {       \"c_Activitytype\": \"1\",       ...     },   ... } ``` *\'Activity type\' is a field type \'List\' (Strings list) with the possible values: \"1\", \"2\" and \"3\". It means that if a different value or type is provided then the request will return an error.* <br><br>If the operation get success then an inactive employee is created and the response will include the provided information and the Kenjo id for the new employee. 
         * @param {EmployeesApiCreateInactiveEmployeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInactiveEmployee(requestParameters: EmployeesApiCreateInactiveEmployeeRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesCreateInactiveEmployeeResponse> {
            return localVarFp.createInactiveEmployee(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deactivates a Kenjo employee given by the employeeId. It sets the isActive field to FALSE and invalidate the access Kenjo for the employee. While the employee is not active it is possible to send activation emails.
         * @param {EmployeesApiDeactivateEmployeeByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateEmployeeById(requestParameters: EmployeesApiDeactivateEmployeeByIdRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deactivateEmployeeById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **account** sections of the existing employees. The account section contains information such as *email*, *external Id*, *language* and *activation status*.
         * @param {EmployeesApiGetAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(requestParameters: EmployeesApiGetAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesGetAccountsResponse> {
            return localVarFp.getAccounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about the **account**, **personal**, **work**, **work schedule**, **address**, **financial** and **home** sections for a given employee id. The *employeeId* param represents a Kenjo employee id.
         * @param {EmployeesApiGetEmployeeInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployeeInformation(requestParameters: EmployeesApiGetEmployeeInformationRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesGetEmployeeInformationResponse> {
            return localVarFp.getEmployeeInformation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the list of employee accounts existing in Kenjo. It is similar to the *_/employees/accounts* endpoint.
         * @param {EmployeesApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(requestParameters: EmployeesApiGetListRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesGetListResponse> {
            return localVarFp.getList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **work schedule** sections of the existing employees.
         * @param {EmployeesApiGetWorkSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkSchedules(requestParameters: EmployeesApiGetWorkSchedulesRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesGetWorkSchedulesResponse> {
            return localVarFp.getWorkSchedules(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **address** sections of the existing employees.
         * @param {EmployeesApiListAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses(requestParameters: EmployeesApiListAddressesRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesListAddressesResponse> {
            return localVarFp.listAddresses(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **financial** sections of the existing employees.
         * @param {EmployeesApiListFinancialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancials(requestParameters: EmployeesApiListFinancialsRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesListFinancialsResponse> {
            return localVarFp.listFinancials(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **home** sections of the existing employees.
         * @param {EmployeesApiListHomesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHomes(requestParameters: EmployeesApiListHomesRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesListHomesResponse> {
            return localVarFp.listHomes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **personal** sections of the existing employees.
         * @param {EmployeesApiListPersonalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonals(requestParameters: EmployeesApiListPersonalsRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesListPersonalsResponse> {
            return localVarFp.listPersonals(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list with the **work** sections of the existing employees.
         * @param {EmployeesApiListWorksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorks(requestParameters: EmployeesApiListWorksRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesListWorksResponse> {
            return localVarFp.listWorks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **address** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'province\' belongs to the \'address\' section*:   ```   {     ...,     \"country\": \"ES\",     \"c_province\": \"MD\",     ...   } ``` *\'province\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddress(requestParameters: EmployeesApiUpdateAddressRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdateAddressResponse> {
            return localVarFp.updateAddress(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **account** section for a given employee id. The operation only updates the fields provided in the body.
         * @param {EmployeesApiUpdateEmployeeAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployeeAccounts(requestParameters: EmployeesApiUpdateEmployeeAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdateEmployeeAccountsResponse> {
            return localVarFp.updateEmployeeAccounts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **financial** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'special tax\' belongs to the \'financial\' section*:   ```   {     ...,     \"iban\": \"ES2345123456789077\",     \"c_specialtax\": 1500,     ...   } ``` *\'special tax\' is a field type \'Number\'. It means that if a different type of data (string or boolean) is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateFinancialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFinancials(requestParameters: EmployeesApiUpdateFinancialsRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdateFinancialsResponse> {
            return localVarFp.updateFinancials(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **home** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'pet name\' belongs to the \'home\' section*:   ```   {     ...,     \"maritalStatus\": \"Divorced\",     \"c_petname\": \"Boliche\",     ...   } ``` *\'pet name\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateHomeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHome(requestParameters: EmployeesApiUpdateHomeRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdateHomeResponse> {
            return localVarFp.updateHome(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **personal** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'category\' belongs to the \'personal\' section*:   ```   {     ...,     \"lastName\": \"Nadie\",     \"c_category\": \"Good\",     ...   } ``` *\'category\' is a field type \'List\' (Strings list) with the possible values: \"Good\" and \"Bad\". It means that if a different value or type is provided then the request will return an error.* 
         * @param {EmployeesApiUpdatePersonalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonals(requestParameters: EmployeesApiUpdatePersonalsRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdatePersonalsResponse> {
            return localVarFp.updatePersonals(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **work schedule** section for a given employee id. The operation only updates the fields provided in the body.
         * @param {EmployeesApiUpdateWorkScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkSchedule(requestParameters: EmployeesApiUpdateWorkScheduleRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdateWorkScheduleResponse> {
            return localVarFp.updateWorkSchedule(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the employee **work** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'activity type\' belongs to the \'personal\' section*:   ```   {     ...,     \"companyId\": \"61d874aef37c05cfba4f1b38\",     \"c_activityType\": \"1\",     ...   } ``` *\'activity Type\' is a field type \'List\' (Strings list) with the possible values: \"1\" and \"2\". It means that if a different value or type is provided then the request will return an error.* 
         * @param {EmployeesApiUpdateWorksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorks(requestParameters: EmployeesApiUpdateWorksRequest, options?: AxiosRequestConfig): AxiosPromise<EmployeesUpdateWorksResponse> {
            return localVarFp.updateWorks(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activateEmployee operation in EmployeesApi.
 * @export
 * @interface EmployeesApiActivateEmployeeRequest
 */
export type EmployeesApiActivateEmployeeRequest = {
    
    /**
    * The _id of the employee to send the activation email.
    * @type {string}
    * @memberof EmployeesApiActivateEmployee
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiActivateEmployee
    */
    readonly authorization: string
    
}

/**
 * Request parameters for createInactiveEmployee operation in EmployeesApi.
 * @export
 * @interface EmployeesApiCreateInactiveEmployeeRequest
 */
export type EmployeesApiCreateInactiveEmployeeRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiCreateInactiveEmployee
    */
    readonly authorization: string
    
} & EmployeesCreateInactiveEmployeeRequest

/**
 * Request parameters for deactivateEmployeeById operation in EmployeesApi.
 * @export
 * @interface EmployeesApiDeactivateEmployeeByIdRequest
 */
export type EmployeesApiDeactivateEmployeeByIdRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiDeactivateEmployeeById
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiDeactivateEmployeeById
    */
    readonly authorization: string
    
}

/**
 * Request parameters for getAccounts operation in EmployeesApi.
 * @export
 * @interface EmployeesApiGetAccountsRequest
 */
export type EmployeesApiGetAccountsRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiGetAccounts
    */
    readonly authorization: string
    
    /**
    * The Kenjo email of the employee.
    * @type {string}
    * @memberof EmployeesApiGetAccounts
    */
    readonly email?: string
    
    /**
    * The employee language.
    * @type {'en' | 'de' | 'es'}
    * @memberof EmployeesApiGetAccounts
    */
    readonly language?: 'en' | 'de' | 'es'
    
    /**
    * The external id of the employee.
    * @type {string}
    * @memberof EmployeesApiGetAccounts
    */
    readonly externalId?: string
    
    /**
    * The employee activation status.
    * @type {boolean}
    * @memberof EmployeesApiGetAccounts
    */
    readonly isActive?: boolean
    
}

/**
 * Request parameters for getEmployeeInformation operation in EmployeesApi.
 * @export
 * @interface EmployeesApiGetEmployeeInformationRequest
 */
export type EmployeesApiGetEmployeeInformationRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiGetEmployeeInformation
    */
    readonly authorization: string
    
    /**
    * The _id of the employee to request.
    * @type {string}
    * @memberof EmployeesApiGetEmployeeInformation
    */
    readonly employeeId: string
    
}

/**
 * Request parameters for getList operation in EmployeesApi.
 * @export
 * @interface EmployeesApiGetListRequest
 */
export type EmployeesApiGetListRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiGetList
    */
    readonly authorization: string
    
}

/**
 * Request parameters for getWorkSchedules operation in EmployeesApi.
 * @export
 * @interface EmployeesApiGetWorkSchedulesRequest
 */
export type EmployeesApiGetWorkSchedulesRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiGetWorkSchedules
    */
    readonly authorization: string
    
    /**
    * The activation status of attendance tracking for the employee.
    * @type {boolean}
    * @memberof EmployeesApiGetWorkSchedules
    */
    readonly trackAttendance?: boolean
    
}

/**
 * Request parameters for listAddresses operation in EmployeesApi.
 * @export
 * @interface EmployeesApiListAddressesRequest
 */
export type EmployeesApiListAddressesRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiListAddresses
    */
    readonly authorization: string
    
    /**
    * The name of the street.
    * @type {string}
    * @memberof EmployeesApiListAddresses
    */
    readonly street?: string
    
    /**
    * The postal code.
    * @type {string}
    * @memberof EmployeesApiListAddresses
    */
    readonly postalCode?: string
    
    /**
    * The city.
    * @type {string}
    * @memberof EmployeesApiListAddresses
    */
    readonly city?: string
    
    /**
    * The country code in ISO 3166-1 alpha-2.
    * @type {string}
    * @memberof EmployeesApiListAddresses
    */
    readonly country?: string
    
}

/**
 * Request parameters for listFinancials operation in EmployeesApi.
 * @export
 * @interface EmployeesApiListFinancialsRequest
 */
export type EmployeesApiListFinancialsRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly authorization: string
    
    /**
    * The accounts holder\'s name.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly accountHolderName?: string
    
    /**
    * The bank name.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly bankName?: string
    
    /**
    * The account number.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly accountNumber?: string
    
    /**
    * The IBAN.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly iban?: string
    
    /**
    * The SWIFT code.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly swiftCode?: string
    
    /**
    * The national id document
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly nationalId?: string
    
    /**
    * The passport number.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly passport?: string
    
    /**
    * The national insurance number.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly nationalInsuranceNumber?: string
    
    /**
    * The tax number.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly taxCode?: string
    
    /**
    * The tax identification number.
    * @type {string}
    * @memberof EmployeesApiListFinancials
    */
    readonly taxIdentificationNumber?: string
    
}

/**
 * Request parameters for listHomes operation in EmployeesApi.
 * @export
 * @interface EmployeesApiListHomesRequest
 */
export type EmployeesApiListHomesRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly authorization: string
    
    /**
    * The marital status. Only is valid one of the following values \"Divorced\", \"Domestic Partnership\", \"Married\", \"Separated\", \"Single\", \"Widowed\".
    * @type {'Divorced' | 'Domestic Partnership' | 'Married' | 'Separated' | 'Single' | 'Widowed'}
    * @memberof EmployeesApiListHomes
    */
    readonly maritalStatus?: 'Divorced' | 'Domestic Partnership' | 'Married' | 'Separated' | 'Single' | 'Widowed'
    
    /**
    * The first name of the employee\'s spouse.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly spouseFirstName?: string
    
    /**
    * The last name of the employee\'s spouse.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly spouseLastName?: string
    
    /**
    * The birth date of the employee\'s spouse. Format YYYY-MM-DDThh:mm:ss.000Z.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly spouseBirthdate?: string
    
    /**
    * The employee\'s spouse gender. Only is valid one of the following values \'Male\' (male), \'Female\' (female) or \'Other\' (other).
    * @type {'Male' | 'Female' | 'Other'}
    * @memberof EmployeesApiListHomes
    */
    readonly spouseGender?: 'Male' | 'Female' | 'Other'
    
    /**
    * The employee personal email.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly personalEmail?: string
    
    /**
    * The employee personal phone.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly personalPhone?: string
    
    /**
    * The employee personal mobile.
    * @type {string}
    * @memberof EmployeesApiListHomes
    */
    readonly personalMobile?: string
    
}

/**
 * Request parameters for listPersonals operation in EmployeesApi.
 * @export
 * @interface EmployeesApiListPersonalsRequest
 */
export type EmployeesApiListPersonalsRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiListPersonals
    */
    readonly authorization: string
    
    /**
    * The name of the Kenjo employee. This field is required.
    * @type {string}
    * @memberof EmployeesApiListPersonals
    */
    readonly firstName?: string
    
    /**
    * The surname of the Kenjo employee. This field is required.
    * @type {string}
    * @memberof EmployeesApiListPersonals
    */
    readonly lastName?: string
    
    /**
    * The composition of firstName and lastName of the Kenjo employee.
    * @type {string}
    * @memberof EmployeesApiListPersonals
    */
    readonly displayName?: string
    
    /**
    * The employee gender. Only is valid one of the following values \'Male\' (male), \'Female\' (female) or \'Other\' (other).
    * @type {'Male' | 'Female' | 'Other'}
    * @memberof EmployeesApiListPersonals
    */
    readonly gender?: 'Male' | 'Female' | 'Other'
    
    /**
    * The employee birth date. Format YYYY-MM-DDThh:00:00.000Z.
    * @type {string}
    * @memberof EmployeesApiListPersonals
    */
    readonly birthdate?: string
    
}

/**
 * Request parameters for listWorks operation in EmployeesApi.
 * @export
 * @interface EmployeesApiListWorksRequest
 */
export type EmployeesApiListWorksRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly authorization: string
    
    /**
    * The company id of the Kenjo employee.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly companyId?: string
    
    /**
    * The office id of the Kenjo employee.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly officeId?: string
    
    /**
    * The department id of the Kenjo employee.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly departmentId?: string
    
    /**
    * The starting date of the Kenjo employee in format YYYY-MM-DDThh:mm:ss.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly startDate?: string
    
    /**
    * The job title of the employee.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly jobTitle?: string
    
    /**
    * The work phone of the employee.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly workPhone?: string
    
    /**
    * The work mobile of the employee.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly workMobile?: string
    
    /**
    * Allow to indicate if the employee has or not the assistant role.
    * @type {boolean}
    * @memberof EmployeesApiListWorks
    */
    readonly isAssistant?: boolean
    
    /**
    * The probation period of the employee. Format YYYY-MM-DDThh:mm:ss.000Z.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly probationPeriodEnd?: string
    
    /**
    * The Kenjo employee id of the user to whom the employee reports. The employee id to assign can be an active or inactive user. Trying to assign the own employee id or the id of someone who is already reporting will arise an error.
    * @type {string}
    * @memberof EmployeesApiListWorks
    */
    readonly reportsToId?: string
    
}

/**
 * Request parameters for updateAddress operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdateAddressRequest
 */
export type EmployeesApiUpdateAddressRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdateAddress
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdateAddress
    */
    readonly authorization: string
    
} & EmployeesUpdateAddressRequest

/**
 * Request parameters for updateEmployeeAccounts operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdateEmployeeAccountsRequest
 */
export type EmployeesApiUpdateEmployeeAccountsRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdateEmployeeAccounts
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdateEmployeeAccounts
    */
    readonly authorization: string
    
} & EmployeesUpdateEmployeeAccountsRequest

/**
 * Request parameters for updateFinancials operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdateFinancialsRequest
 */
export type EmployeesApiUpdateFinancialsRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdateFinancials
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdateFinancials
    */
    readonly authorization: string
    
} & EmployeesUpdateFinancialsRequest

/**
 * Request parameters for updateHome operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdateHomeRequest
 */
export type EmployeesApiUpdateHomeRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdateHome
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdateHome
    */
    readonly authorization: string
    
} & EmployeesUpdateHomeRequest

/**
 * Request parameters for updatePersonals operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdatePersonalsRequest
 */
export type EmployeesApiUpdatePersonalsRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdatePersonals
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdatePersonals
    */
    readonly authorization: string
    
} & EmployeesUpdatePersonalsRequest

/**
 * Request parameters for updateWorkSchedule operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdateWorkScheduleRequest
 */
export type EmployeesApiUpdateWorkScheduleRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdateWorkSchedule
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdateWorkSchedule
    */
    readonly authorization: string
    
} & EmployeesUpdateWorkScheduleRequest

/**
 * Request parameters for updateWorks operation in EmployeesApi.
 * @export
 * @interface EmployeesApiUpdateWorksRequest
 */
export type EmployeesApiUpdateWorksRequest = {
    
    /**
    * The _id of the employee to update.
    * @type {string}
    * @memberof EmployeesApiUpdateWorks
    */
    readonly employeeId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof EmployeesApiUpdateWorks
    */
    readonly authorization: string
    
} & EmployeesUpdateWorksRequest

/**
 * EmployeesApiGenerated - object-oriented interface
 * @export
 * @class EmployeesApiGenerated
 * @extends {BaseAPI}
 */
export class EmployeesApiGenerated extends BaseAPI {
    /**
     * This endpoint activates a Kenjo employee given by the employeeId. It sends an email to the recipient of the employee email to start the onboarding process. Once the password is filled, the employee changes to \'active\' (\'isActive\' = TRUE). While the employee is not active it is possible to send activation emails.
     * @param {EmployeesApiActivateEmployeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public activateEmployee(requestParameters: EmployeesApiActivateEmployeeRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).activateEmployee(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates a deactivated employee in Kenjo, the \'isActive\' field set to false. To activate an employee use the put /activate method. This method will send an activation message to the employee email to complete the activation through the onboarding wizard. <br><br>The field *email* is required and must be unique. Also *firstName*, *lastName* and *companyId* are required fields. If the work schedule is not provided then all the days of the week except Saturdays and Sundays are set to true. If the *language* is not specified, the assigned company language will be set by default. <br><br>**Custom fields** information can be provided in this operation for the **personal**, **work**, **address**, **financial** and **home** sections. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'Activity type\' belongs to the section \'work\'*:   ``` ... {   ...     \"work\": {       \"c_Activitytype\": \"1\",       ...     },   ... } ``` *\'Activity type\' is a field type \'List\' (Strings list) with the possible values: \"1\", \"2\" and \"3\". It means that if a different value or type is provided then the request will return an error.* <br><br>If the operation get success then an inactive employee is created and the response will include the provided information and the Kenjo id for the new employee. 
     * @param {EmployeesApiCreateInactiveEmployeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public createInactiveEmployee(requestParameters: EmployeesApiCreateInactiveEmployeeRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).createInactiveEmployee(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deactivates a Kenjo employee given by the employeeId. It sets the isActive field to FALSE and invalidate the access Kenjo for the employee. While the employee is not active it is possible to send activation emails.
     * @param {EmployeesApiDeactivateEmployeeByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public deactivateEmployeeById(requestParameters: EmployeesApiDeactivateEmployeeByIdRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).deactivateEmployeeById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **account** sections of the existing employees. The account section contains information such as *email*, *external Id*, *language* and *activation status*.
     * @param {EmployeesApiGetAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public getAccounts(requestParameters: EmployeesApiGetAccountsRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).getAccounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about the **account**, **personal**, **work**, **work schedule**, **address**, **financial** and **home** sections for a given employee id. The *employeeId* param represents a Kenjo employee id.
     * @param {EmployeesApiGetEmployeeInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public getEmployeeInformation(requestParameters: EmployeesApiGetEmployeeInformationRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).getEmployeeInformation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the list of employee accounts existing in Kenjo. It is similar to the *_/employees/accounts* endpoint.
     * @param {EmployeesApiGetListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public getList(requestParameters: EmployeesApiGetListRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).getList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **work schedule** sections of the existing employees.
     * @param {EmployeesApiGetWorkSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public getWorkSchedules(requestParameters: EmployeesApiGetWorkSchedulesRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).getWorkSchedules(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **address** sections of the existing employees.
     * @param {EmployeesApiListAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public listAddresses(requestParameters: EmployeesApiListAddressesRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).listAddresses(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **financial** sections of the existing employees.
     * @param {EmployeesApiListFinancialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public listFinancials(requestParameters: EmployeesApiListFinancialsRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).listFinancials(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **home** sections of the existing employees.
     * @param {EmployeesApiListHomesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public listHomes(requestParameters: EmployeesApiListHomesRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).listHomes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **personal** sections of the existing employees.
     * @param {EmployeesApiListPersonalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public listPersonals(requestParameters: EmployeesApiListPersonalsRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).listPersonals(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list with the **work** sections of the existing employees.
     * @param {EmployeesApiListWorksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public listWorks(requestParameters: EmployeesApiListWorksRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).listWorks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **address** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'province\' belongs to the \'address\' section*:   ```   {     ...,     \"country\": \"ES\",     \"c_province\": \"MD\",     ...   } ``` *\'province\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
     * @param {EmployeesApiUpdateAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updateAddress(requestParameters: EmployeesApiUpdateAddressRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updateAddress(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **account** section for a given employee id. The operation only updates the fields provided in the body.
     * @param {EmployeesApiUpdateEmployeeAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updateEmployeeAccounts(requestParameters: EmployeesApiUpdateEmployeeAccountsRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updateEmployeeAccounts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **financial** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'special tax\' belongs to the \'financial\' section*:   ```   {     ...,     \"iban\": \"ES2345123456789077\",     \"c_specialtax\": 1500,     ...   } ``` *\'special tax\' is a field type \'Number\'. It means that if a different type of data (string or boolean) is provided then the request will return an error.* 
     * @param {EmployeesApiUpdateFinancialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updateFinancials(requestParameters: EmployeesApiUpdateFinancialsRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updateFinancials(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **home** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'pet name\' belongs to the \'home\' section*:   ```   {     ...,     \"maritalStatus\": \"Divorced\",     \"c_petname\": \"Boliche\",     ...   } ``` *\'pet name\' is a field type \'String\'. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
     * @param {EmployeesApiUpdateHomeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updateHome(requestParameters: EmployeesApiUpdateHomeRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updateHome(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **personal** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'category\' belongs to the \'personal\' section*:   ```   {     ...,     \"lastName\": \"Nadie\",     \"c_category\": \"Good\",     ...   } ``` *\'category\' is a field type \'List\' (Strings list) with the possible values: \"Good\" and \"Bad\". It means that if a different value or type is provided then the request will return an error.* 
     * @param {EmployeesApiUpdatePersonalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updatePersonals(requestParameters: EmployeesApiUpdatePersonalsRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updatePersonals(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **work schedule** section for a given employee id. The operation only updates the fields provided in the body.
     * @param {EmployeesApiUpdateWorkScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updateWorkSchedule(requestParameters: EmployeesApiUpdateWorkScheduleRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updateWorkSchedule(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the employee **work** section for a given employee id. The operation only updates the fields provided in the body. <br><br>**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with \'c_\' and the rest is composed by the trimmed name (spaces are removed). <br><br> Example: <br> *The custom field \'activity type\' belongs to the \'personal\' section*:   ```   {     ...,     \"companyId\": \"61d874aef37c05cfba4f1b38\",     \"c_activityType\": \"1\",     ...   } ``` *\'activity Type\' is a field type \'List\' (Strings list) with the possible values: \"1\" and \"2\". It means that if a different value or type is provided then the request will return an error.* 
     * @param {EmployeesApiUpdateWorksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiGenerated
     */
    public updateWorks(requestParameters: EmployeesApiUpdateWorksRequest, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).updateWorks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
