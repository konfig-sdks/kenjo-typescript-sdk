/* tslint:disable */
/* eslint-disable */
/*
Kenjo API

Before starting to use the Kenjo API, you have to request the API activation for a sandbox or production environment to the Kenjo Customer Success team. After that, an admin user has to go to *Settings > Integrations > API keys*, to generate the **API Key**. Follow the steps described in the **Autentication section** of this document. <br>The API key is needed to request the bearer token. Each endpoint callout requires a valid bearer token in the Authorization header. Once the token is retrieved, it will be useful during the time limit indicated by the 'expiration date'.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AuthenticationCreateBearerToken400Response } from '../models';
// @ts-ignore
import { TimeOffGetRequestsByDateResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TimeOffApi - axios parameter creator
 * @export
 */
export const TimeOffApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a paginated list of time off requests for a given date range.The maximum number of time off requests to retrieve once is 92 days, so the URL params *from* and *to* are mandatory. The URL params help to return more accurate results.
         * @param {string} authorization A valid bearer token.
         * @param {string} from A date in format YYYY-MM-DD to indicate the starting point. It needs to be equals or less than the *to* param.
         * @param {string} to A date in format YYYY-MM-DD to indicate the ending point. It needs to be equals or greater than the *from* param.
         * @param {string} [userId] This field allows to return only the time off requests for a given *_userId*.
         * @param {string} [timeOffTypeId] This field allows to filter by time-off type Id.
         * @param {'Approved' | 'Declined' | 'Cancelled' | 'Pending' | 'Submitted' | 'Processed' | 'CancelledAfterProcessed' | 'InApproval'} [status] This field allows to filter by the time-off request status.
         * @param {number} [offset] Optional filter for pagination proposals. Determines the number of pages to skip when pagination is being used. If this value is not provided, by default the offset will be 1.
         * @param {number} [limit] Optional filter for pagination proposals. The maximum number of rows to retrieve which determines the size of the page. If this value is not provided then the limit will be 50 users. The maximum value of the limit is 100 users per page. Only are valid the following limit values: 25, 50 and 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestsByDate: async (authorization: string, from: string, to: string, userId?: string, timeOffTypeId?: string, status?: 'Approved' | 'Declined' | 'Cancelled' | 'Pending' | 'Submitted' | 'Processed' | 'CancelledAfterProcessed' | 'InApproval', offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getRequestsByDate', 'authorization', authorization)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getRequestsByDate', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getRequestsByDate', 'to', to)
            const localVarPath = `/time-off/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (userId !== undefined) {
                localVarQueryParameter['_userId'] = userId;
            }

            if (timeOffTypeId !== undefined) {
                localVarQueryParameter['_timeOffTypeId'] = timeOffTypeId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/time-off/requests',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeOffApi - functional programming interface
 * @export
 */
export const TimeOffApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeOffApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a paginated list of time off requests for a given date range.The maximum number of time off requests to retrieve once is 92 days, so the URL params *from* and *to* are mandatory. The URL params help to return more accurate results.
         * @param {TimeOffApiGetRequestsByDateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestsByDate(requestParameters: TimeOffApiGetRequestsByDateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeOffGetRequestsByDateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestsByDate(requestParameters.authorization, requestParameters.from, requestParameters.to, requestParameters.userId, requestParameters.timeOffTypeId, requestParameters.status, requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimeOffApi - factory interface
 * @export
 */
export const TimeOffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeOffApiFp(configuration)
    return {
        /**
         * This endpoint returns a paginated list of time off requests for a given date range.The maximum number of time off requests to retrieve once is 92 days, so the URL params *from* and *to* are mandatory. The URL params help to return more accurate results.
         * @param {TimeOffApiGetRequestsByDateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestsByDate(requestParameters: TimeOffApiGetRequestsByDateRequest, options?: AxiosRequestConfig): AxiosPromise<TimeOffGetRequestsByDateResponse> {
            return localVarFp.getRequestsByDate(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRequestsByDate operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetRequestsByDateRequest
 */
export type TimeOffApiGetRequestsByDateRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly authorization: string
    
    /**
    * A date in format YYYY-MM-DD to indicate the starting point. It needs to be equals or less than the *to* param.
    * @type {string}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly from: string
    
    /**
    * A date in format YYYY-MM-DD to indicate the ending point. It needs to be equals or greater than the *from* param.
    * @type {string}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly to: string
    
    /**
    * This field allows to return only the time off requests for a given *_userId*.
    * @type {string}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly userId?: string
    
    /**
    * This field allows to filter by time-off type Id.
    * @type {string}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly timeOffTypeId?: string
    
    /**
    * This field allows to filter by the time-off request status.
    * @type {'Approved' | 'Declined' | 'Cancelled' | 'Pending' | 'Submitted' | 'Processed' | 'CancelledAfterProcessed' | 'InApproval'}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly status?: 'Approved' | 'Declined' | 'Cancelled' | 'Pending' | 'Submitted' | 'Processed' | 'CancelledAfterProcessed' | 'InApproval'
    
    /**
    * Optional filter for pagination proposals. Determines the number of pages to skip when pagination is being used. If this value is not provided, by default the offset will be 1.
    * @type {number}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly offset?: number
    
    /**
    * Optional filter for pagination proposals. The maximum number of rows to retrieve which determines the size of the page. If this value is not provided then the limit will be 50 users. The maximum value of the limit is 100 users per page. Only are valid the following limit values: 25, 50 and 100.
    * @type {number}
    * @memberof TimeOffApiGetRequestsByDate
    */
    readonly limit?: number
    
}

/**
 * TimeOffApiGenerated - object-oriented interface
 * @export
 * @class TimeOffApiGenerated
 * @extends {BaseAPI}
 */
export class TimeOffApiGenerated extends BaseAPI {
    /**
     * This endpoint returns a paginated list of time off requests for a given date range.The maximum number of time off requests to retrieve once is 92 days, so the URL params *from* and *to* are mandatory. The URL params help to return more accurate results.
     * @param {TimeOffApiGetRequestsByDateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getRequestsByDate(requestParameters: TimeOffApiGetRequestsByDateRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getRequestsByDate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
