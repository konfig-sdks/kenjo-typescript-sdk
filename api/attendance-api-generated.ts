/* tslint:disable */
/* eslint-disable */
/*
Kenjo API

Before starting to use the Kenjo API, you have to request the API activation for a sandbox or production environment to the Kenjo Customer Success team. After that, an admin user has to go to *Settings > Integrations > API keys*, to generate the **API Key**. Follow the steps described in the **Autentication section** of this document. <br>The API key is needed to request the bearer token. Each endpoint callout requires a valid bearer token in the Authorization header. Once the token is retrieved, it will be useful during the time limit indicated by the 'expiration date'.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttendanceCreateEntryRequest } from '../models';
// @ts-ignore
import { AttendanceCreateEntryRequestBreaksInner } from '../models';
// @ts-ignore
import { AttendanceCreateEntryResponse } from '../models';
// @ts-ignore
import { AttendanceCreateTrackTimeRequest } from '../models';
// @ts-ignore
import { AttendanceCreateTrackTimeResponse } from '../models';
// @ts-ignore
import { AttendanceGetByIdResponse } from '../models';
// @ts-ignore
import { AttendanceGetCategoriesResponse } from '../models';
// @ts-ignore
import { AttendanceGetExpectedTimeByUserResponse } from '../models';
// @ts-ignore
import { AttendanceGetListResponseInner } from '../models';
// @ts-ignore
import { AttendanceUpdateEntryRequest } from '../models';
// @ts-ignore
import { AttendanceUpdateEntryRequestBreaksInner } from '../models';
// @ts-ignore
import { AttendanceUpdateEntryResponse } from '../models';
// @ts-ignore
import { AuthenticationCreateBearerToken400Response } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AttendanceApi - axios parameter creator
 * @export
 */
export const AttendanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates an attendance entry for a one employee, so an user *identifier* is required to build this relationship. The following *identifiers* are the valid ones: **userId**, **email** or **externalId**. Also one **startTime** and one **date** are required.<br>The new entry will have an unique identifier **_id**. This value is returned in the body response.<br><br> A day accepts many attendance entries per employee but they cannot be overlapped. It means that if, for example, *there is an entry the 2021-06-10 between 09:00 and 10:00 for the user E-111, then the creation of an new entry for E-111 in the 2021-06-10 whose startDate or endDate is between 09:00 and 10:00 will become a BAD REQUEST*.
         * @param {string} authorization A valid bearer token.
         * @param {AttendanceCreateEntryRequest} attendanceCreateEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntry: async (authorization: string, attendanceCreateEntryRequest: AttendanceCreateEntryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createEntry', 'authorization', authorization)
            // verify required parameter 'attendanceCreateEntryRequest' is not null or undefined
            assertParamExists('createEntry', 'attendanceCreateEntryRequest', attendanceCreateEntryRequest)
            const localVarPath = `/attendances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: attendanceCreateEntryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceCreateEntryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint tracks time only providing the following information: **employee identifier** and a **date time**. The following identifiers are the valid ones: **userId**, **email** or **externalId**, only one of them is required. This action abstracts and simplifies the entries tracking, ensuring internally the order and transforming each track action to a Kenjo user attendance format.<br><br>Example: Three calls for the employee E-111 to the *_/track-time* endpoint contains the following data:<br>T1: 2021-01-01T08:00:00<br>T2: 2021-01-01T09:00:00<br>T3: 2021-01-01T10:00:00<br>The three calls order is T1, T2, T3.<br><br>Then in Kenjo there will be 2 attendance pairs:<br>1: 08:00 / 09:00<br>2: 10:00 / --:--<br>The second pair is open, with no **endTime** info, until a new one comes. <br><br>If there is a new track: 2021-01-01T12:00:00, then the result will be:<br>1: 08:00 / 09:00<br>2: 10:00 / 12:00<br>If the track is 2021-01-01T07:00:00 instead, then the previous tracks are reordered to be consistent with concept of attendance pairs:<br>1: 07:00 / 08:00<br>2: 09:00 / 10:00
         * @param {string} authorization A valid bearer token.
         * @param {AttendanceCreateTrackTimeRequest} attendanceCreateTrackTimeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackTime: async (authorization: string, attendanceCreateTrackTimeRequest: AttendanceCreateTrackTimeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createTrackTime', 'authorization', authorization)
            // verify required parameter 'attendanceCreateTrackTimeRequest' is not null or undefined
            assertParamExists('createTrackTime', 'attendanceCreateTrackTimeRequest', attendanceCreateTrackTimeRequest)
            const localVarPath = `/attendances/track-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: attendanceCreateTrackTimeRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances/track-time',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceCreateTrackTimeRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns one attendance entry specified by  **attendanceId**.
         * @param {string} attendanceId The _id of the attendance entry to request.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (attendanceId: string, authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attendanceId' is not null or undefined
            assertParamExists('getById', 'attendanceId', attendanceId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getById', 'authorization', authorization)
            const localVarPath = `/attendances/{attendanceId}`
                .replace(`{${"attendanceId"}}`, encodeURIComponent(String(attendanceId !== undefined ? attendanceId : `-attendanceId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances/{attendanceId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns an array of objects. Every object contains an attendance category.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getCategories', 'authorization', authorization)
            const localVarPath = `/attendances/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances/categories',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a paginated list of expected time by user for a given date range.
         * @param {string} from A date in format YYYY-MM-DD to indicate the starting point.
         * @param {string} to A date in format YYYY-MM-DD to indicate the ending point.
         * @param {string} authorization A valid bearer token.
         * @param {string} [companyId] Optional filter. The company id of the Kenjo employee.
         * @param {string} [officeId] Optional filter. The office id of the Kenjo employee.
         * @param {string} [departmentId] Optional filter. The department id of the Kenjo employee.
         * @param {string} [userId] Optional filter. The id of the Kenjo employee. It accepts 2 formats:&lt;br&gt;&lt;br&gt; 1. An unique string with the Kenjo employee id. &lt;br&gt;Example: *userId&#x3D;80a2db290da29e126a18789c* &lt;br&gt;&lt;br&gt; 2. A string with more than one Kenjo employee ids separated by commas (until 15 ids as maximum). &lt;br&gt;Example: *userId&#x3D;80a2db290da29e126a18789c,80a2db290da29e126a18789b,80a2db290da29e126a187891*
         * @param {number} [offset] Optional filter for pagination proposals. Determines the number of pages to skip when pagination is being used. If this value is not provided, by default the offset will be 1.
         * @param {number} [limit] Optional filter for pagination proposals. The maximum number of rows to retrieve which determines the size of the page. If this value is not provided then the limit will be 50 users. The maximum value of the limit is 100 users per page. Only are valid the following limit values: 25, 50 and 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpectedTimeByUser: async (from: string, to: string, authorization: string, companyId?: string, officeId?: string, departmentId?: string, userId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getExpectedTimeByUser', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getExpectedTimeByUser', 'to', to)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getExpectedTimeByUser', 'authorization', authorization)
            const localVarPath = `/attendances/expected-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (officeId !== undefined) {
                localVarQueryParameter['officeId'] = officeId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances/expected-time',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns an array of objects with all the existing attendance entries within Kenjo for a maximum of 31 days, defined by the required params **from** and **to**. Every object contains an attendance entry.
         * @param {string} from A date in format YYYY-MM-DD to indicate the starting point.
         * @param {string} to A date in format YYYY-MM-DD to indicate the ending point.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (from: string, to: string, authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getList', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getList', 'to', to)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getList', 'authorization', authorization)
            const localVarPath = `/attendances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint delete the attendance entry specified by **attendanceId**.
         * @param {string} attendanceId The Kenjo _id of the attendance entry to remove.
         * @param {string} authorization A valid bearer token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeById: async (attendanceId: string, authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attendanceId' is not null or undefined
            assertParamExists('removeById', 'attendanceId', attendanceId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('removeById', 'authorization', authorization)
            const localVarPath = `/attendances/{attendanceId}`
                .replace(`{${"attendanceId"}}`, encodeURIComponent(String(attendanceId !== undefined ? attendanceId : `-attendanceId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances/{attendanceId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the attendance entry specified by **attendanceId**. Only the fields submitted in the body will be updated.
         * @param {string} attendanceId The _id of the attendance entry to update.
         * @param {string} authorization A valid bearer token.
         * @param {AttendanceUpdateEntryRequest} attendanceUpdateEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntry: async (attendanceId: string, authorization: string, attendanceUpdateEntryRequest: AttendanceUpdateEntryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attendanceId' is not null or undefined
            assertParamExists('updateEntry', 'attendanceId', attendanceId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateEntry', 'authorization', authorization)
            // verify required parameter 'attendanceUpdateEntryRequest' is not null or undefined
            assertParamExists('updateEntry', 'attendanceUpdateEntryRequest', attendanceUpdateEntryRequest)
            const localVarPath = `/attendances/{attendanceId}`
                .replace(`{${"attendanceId"}}`, encodeURIComponent(String(attendanceId !== undefined ? attendanceId : `-attendanceId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: attendanceUpdateEntryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/attendances/{attendanceId}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceUpdateEntryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttendanceApi - functional programming interface
 * @export
 */
export const AttendanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttendanceApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates an attendance entry for a one employee, so an user *identifier* is required to build this relationship. The following *identifiers* are the valid ones: **userId**, **email** or **externalId**. Also one **startTime** and one **date** are required.<br>The new entry will have an unique identifier **_id**. This value is returned in the body response.<br><br> A day accepts many attendance entries per employee but they cannot be overlapped. It means that if, for example, *there is an entry the 2021-06-10 between 09:00 and 10:00 for the user E-111, then the creation of an new entry for E-111 in the 2021-06-10 whose startDate or endDate is between 09:00 and 10:00 will become a BAD REQUEST*.
         * @param {AttendanceApiCreateEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntry(requestParameters: AttendanceApiCreateEntryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceCreateEntryResponse>> {
            const attendanceCreateEntryRequest: AttendanceCreateEntryRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                externalId: requestParameters.externalId,
                date: requestParameters.date,
                startTime: requestParameters.startTime,
                endTime: requestParameters.endTime,
                breaks: requestParameters.breaks,
                comment: requestParameters.comment
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntry(requestParameters.authorization, attendanceCreateEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint tracks time only providing the following information: **employee identifier** and a **date time**. The following identifiers are the valid ones: **userId**, **email** or **externalId**, only one of them is required. This action abstracts and simplifies the entries tracking, ensuring internally the order and transforming each track action to a Kenjo user attendance format.<br><br>Example: Three calls for the employee E-111 to the *_/track-time* endpoint contains the following data:<br>T1: 2021-01-01T08:00:00<br>T2: 2021-01-01T09:00:00<br>T3: 2021-01-01T10:00:00<br>The three calls order is T1, T2, T3.<br><br>Then in Kenjo there will be 2 attendance pairs:<br>1: 08:00 / 09:00<br>2: 10:00 / --:--<br>The second pair is open, with no **endTime** info, until a new one comes. <br><br>If there is a new track: 2021-01-01T12:00:00, then the result will be:<br>1: 08:00 / 09:00<br>2: 10:00 / 12:00<br>If the track is 2021-01-01T07:00:00 instead, then the previous tracks are reordered to be consistent with concept of attendance pairs:<br>1: 07:00 / 08:00<br>2: 09:00 / 10:00
         * @param {AttendanceApiCreateTrackTimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrackTime(requestParameters: AttendanceApiCreateTrackTimeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceCreateTrackTimeResponse>> {
            const attendanceCreateTrackTimeRequest: AttendanceCreateTrackTimeRequest = {
                userId: requestParameters.userId,
                email: requestParameters.email,
                externalId: requestParameters.externalId,
                dateTime: requestParameters.dateTime
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrackTime(requestParameters.authorization, attendanceCreateTrackTimeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns one attendance entry specified by  **attendanceId**.
         * @param {AttendanceApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(requestParameters: AttendanceApiGetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceGetByIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(requestParameters.attendanceId, requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns an array of objects. Every object contains an attendance category.
         * @param {AttendanceApiGetCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(requestParameters: AttendanceApiGetCategoriesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceGetCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a paginated list of expected time by user for a given date range.
         * @param {AttendanceApiGetExpectedTimeByUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpectedTimeByUser(requestParameters: AttendanceApiGetExpectedTimeByUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceGetExpectedTimeByUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpectedTimeByUser(requestParameters.from, requestParameters.to, requestParameters.authorization, requestParameters.companyId, requestParameters.officeId, requestParameters.departmentId, requestParameters.userId, requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns an array of objects with all the existing attendance entries within Kenjo for a maximum of 31 days, defined by the required params **from** and **to**. Every object contains an attendance entry.
         * @param {AttendanceApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(requestParameters: AttendanceApiGetListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendanceGetListResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(requestParameters.from, requestParameters.to, requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint delete the attendance entry specified by **attendanceId**.
         * @param {AttendanceApiRemoveByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeById(requestParameters: AttendanceApiRemoveByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeById(requestParameters.attendanceId, requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates the attendance entry specified by **attendanceId**. Only the fields submitted in the body will be updated.
         * @param {AttendanceApiUpdateEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntry(requestParameters: AttendanceApiUpdateEntryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceUpdateEntryResponse>> {
            const attendanceUpdateEntryRequest: AttendanceUpdateEntryRequest = {
                startTime: requestParameters.startTime,
                endTime: requestParameters.endTime,
                breaks: requestParameters.breaks,
                comment: requestParameters.comment
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntry(requestParameters.attendanceId, requestParameters.authorization, attendanceUpdateEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AttendanceApi - factory interface
 * @export
 */
export const AttendanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttendanceApiFp(configuration)
    return {
        /**
         * This endpoint creates an attendance entry for a one employee, so an user *identifier* is required to build this relationship. The following *identifiers* are the valid ones: **userId**, **email** or **externalId**. Also one **startTime** and one **date** are required.<br>The new entry will have an unique identifier **_id**. This value is returned in the body response.<br><br> A day accepts many attendance entries per employee but they cannot be overlapped. It means that if, for example, *there is an entry the 2021-06-10 between 09:00 and 10:00 for the user E-111, then the creation of an new entry for E-111 in the 2021-06-10 whose startDate or endDate is between 09:00 and 10:00 will become a BAD REQUEST*.
         * @param {AttendanceApiCreateEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntry(requestParameters: AttendanceApiCreateEntryRequest, options?: AxiosRequestConfig): AxiosPromise<AttendanceCreateEntryResponse> {
            return localVarFp.createEntry(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint tracks time only providing the following information: **employee identifier** and a **date time**. The following identifiers are the valid ones: **userId**, **email** or **externalId**, only one of them is required. This action abstracts and simplifies the entries tracking, ensuring internally the order and transforming each track action to a Kenjo user attendance format.<br><br>Example: Three calls for the employee E-111 to the *_/track-time* endpoint contains the following data:<br>T1: 2021-01-01T08:00:00<br>T2: 2021-01-01T09:00:00<br>T3: 2021-01-01T10:00:00<br>The three calls order is T1, T2, T3.<br><br>Then in Kenjo there will be 2 attendance pairs:<br>1: 08:00 / 09:00<br>2: 10:00 / --:--<br>The second pair is open, with no **endTime** info, until a new one comes. <br><br>If there is a new track: 2021-01-01T12:00:00, then the result will be:<br>1: 08:00 / 09:00<br>2: 10:00 / 12:00<br>If the track is 2021-01-01T07:00:00 instead, then the previous tracks are reordered to be consistent with concept of attendance pairs:<br>1: 07:00 / 08:00<br>2: 09:00 / 10:00
         * @param {AttendanceApiCreateTrackTimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackTime(requestParameters: AttendanceApiCreateTrackTimeRequest, options?: AxiosRequestConfig): AxiosPromise<AttendanceCreateTrackTimeResponse> {
            return localVarFp.createTrackTime(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns one attendance entry specified by  **attendanceId**.
         * @param {AttendanceApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: AttendanceApiGetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<AttendanceGetByIdResponse> {
            return localVarFp.getById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns an array of objects. Every object contains an attendance category.
         * @param {AttendanceApiGetCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(requestParameters: AttendanceApiGetCategoriesRequest, options?: AxiosRequestConfig): AxiosPromise<AttendanceGetCategoriesResponse> {
            return localVarFp.getCategories(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a paginated list of expected time by user for a given date range.
         * @param {AttendanceApiGetExpectedTimeByUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpectedTimeByUser(requestParameters: AttendanceApiGetExpectedTimeByUserRequest, options?: AxiosRequestConfig): AxiosPromise<AttendanceGetExpectedTimeByUserResponse> {
            return localVarFp.getExpectedTimeByUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns an array of objects with all the existing attendance entries within Kenjo for a maximum of 31 days, defined by the required params **from** and **to**. Every object contains an attendance entry.
         * @param {AttendanceApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(requestParameters: AttendanceApiGetListRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AttendanceGetListResponseInner>> {
            return localVarFp.getList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint delete the attendance entry specified by **attendanceId**.
         * @param {AttendanceApiRemoveByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeById(requestParameters: AttendanceApiRemoveByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the attendance entry specified by **attendanceId**. Only the fields submitted in the body will be updated.
         * @param {AttendanceApiUpdateEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntry(requestParameters: AttendanceApiUpdateEntryRequest, options?: AxiosRequestConfig): AxiosPromise<AttendanceUpdateEntryResponse> {
            return localVarFp.updateEntry(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createEntry operation in AttendanceApi.
 * @export
 * @interface AttendanceApiCreateEntryRequest
 */
export type AttendanceApiCreateEntryRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiCreateEntry
    */
    readonly authorization: string
    
} & AttendanceCreateEntryRequest

/**
 * Request parameters for createTrackTime operation in AttendanceApi.
 * @export
 * @interface AttendanceApiCreateTrackTimeRequest
 */
export type AttendanceApiCreateTrackTimeRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiCreateTrackTime
    */
    readonly authorization: string
    
} & AttendanceCreateTrackTimeRequest

/**
 * Request parameters for getById operation in AttendanceApi.
 * @export
 * @interface AttendanceApiGetByIdRequest
 */
export type AttendanceApiGetByIdRequest = {
    
    /**
    * The _id of the attendance entry to request.
    * @type {string}
    * @memberof AttendanceApiGetById
    */
    readonly attendanceId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiGetById
    */
    readonly authorization: string
    
}

/**
 * Request parameters for getCategories operation in AttendanceApi.
 * @export
 * @interface AttendanceApiGetCategoriesRequest
 */
export type AttendanceApiGetCategoriesRequest = {
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiGetCategories
    */
    readonly authorization: string
    
}

/**
 * Request parameters for getExpectedTimeByUser operation in AttendanceApi.
 * @export
 * @interface AttendanceApiGetExpectedTimeByUserRequest
 */
export type AttendanceApiGetExpectedTimeByUserRequest = {
    
    /**
    * A date in format YYYY-MM-DD to indicate the starting point.
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly from: string
    
    /**
    * A date in format YYYY-MM-DD to indicate the ending point.
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly to: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly authorization: string
    
    /**
    * Optional filter. The company id of the Kenjo employee.
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly companyId?: string
    
    /**
    * Optional filter. The office id of the Kenjo employee.
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly officeId?: string
    
    /**
    * Optional filter. The department id of the Kenjo employee.
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly departmentId?: string
    
    /**
    * Optional filter. The id of the Kenjo employee. It accepts 2 formats:<br><br> 1. An unique string with the Kenjo employee id. <br>Example: *userId=80a2db290da29e126a18789c* <br><br> 2. A string with more than one Kenjo employee ids separated by commas (until 15 ids as maximum). <br>Example: *userId=80a2db290da29e126a18789c,80a2db290da29e126a18789b,80a2db290da29e126a187891*
    * @type {string}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly userId?: string
    
    /**
    * Optional filter for pagination proposals. Determines the number of pages to skip when pagination is being used. If this value is not provided, by default the offset will be 1.
    * @type {number}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly offset?: number
    
    /**
    * Optional filter for pagination proposals. The maximum number of rows to retrieve which determines the size of the page. If this value is not provided then the limit will be 50 users. The maximum value of the limit is 100 users per page. Only are valid the following limit values: 25, 50 and 100.
    * @type {number}
    * @memberof AttendanceApiGetExpectedTimeByUser
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getList operation in AttendanceApi.
 * @export
 * @interface AttendanceApiGetListRequest
 */
export type AttendanceApiGetListRequest = {
    
    /**
    * A date in format YYYY-MM-DD to indicate the starting point.
    * @type {string}
    * @memberof AttendanceApiGetList
    */
    readonly from: string
    
    /**
    * A date in format YYYY-MM-DD to indicate the ending point.
    * @type {string}
    * @memberof AttendanceApiGetList
    */
    readonly to: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiGetList
    */
    readonly authorization: string
    
}

/**
 * Request parameters for removeById operation in AttendanceApi.
 * @export
 * @interface AttendanceApiRemoveByIdRequest
 */
export type AttendanceApiRemoveByIdRequest = {
    
    /**
    * The Kenjo _id of the attendance entry to remove.
    * @type {string}
    * @memberof AttendanceApiRemoveById
    */
    readonly attendanceId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiRemoveById
    */
    readonly authorization: string
    
}

/**
 * Request parameters for updateEntry operation in AttendanceApi.
 * @export
 * @interface AttendanceApiUpdateEntryRequest
 */
export type AttendanceApiUpdateEntryRequest = {
    
    /**
    * The _id of the attendance entry to update.
    * @type {string}
    * @memberof AttendanceApiUpdateEntry
    */
    readonly attendanceId: string
    
    /**
    * A valid bearer token.
    * @type {string}
    * @memberof AttendanceApiUpdateEntry
    */
    readonly authorization: string
    
} & AttendanceUpdateEntryRequest

/**
 * AttendanceApiGenerated - object-oriented interface
 * @export
 * @class AttendanceApiGenerated
 * @extends {BaseAPI}
 */
export class AttendanceApiGenerated extends BaseAPI {
    /**
     * This endpoint creates an attendance entry for a one employee, so an user *identifier* is required to build this relationship. The following *identifiers* are the valid ones: **userId**, **email** or **externalId**. Also one **startTime** and one **date** are required.<br>The new entry will have an unique identifier **_id**. This value is returned in the body response.<br><br> A day accepts many attendance entries per employee but they cannot be overlapped. It means that if, for example, *there is an entry the 2021-06-10 between 09:00 and 10:00 for the user E-111, then the creation of an new entry for E-111 in the 2021-06-10 whose startDate or endDate is between 09:00 and 10:00 will become a BAD REQUEST*.
     * @param {AttendanceApiCreateEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public createEntry(requestParameters: AttendanceApiCreateEntryRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).createEntry(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint tracks time only providing the following information: **employee identifier** and a **date time**. The following identifiers are the valid ones: **userId**, **email** or **externalId**, only one of them is required. This action abstracts and simplifies the entries tracking, ensuring internally the order and transforming each track action to a Kenjo user attendance format.<br><br>Example: Three calls for the employee E-111 to the *_/track-time* endpoint contains the following data:<br>T1: 2021-01-01T08:00:00<br>T2: 2021-01-01T09:00:00<br>T3: 2021-01-01T10:00:00<br>The three calls order is T1, T2, T3.<br><br>Then in Kenjo there will be 2 attendance pairs:<br>1: 08:00 / 09:00<br>2: 10:00 / --:--<br>The second pair is open, with no **endTime** info, until a new one comes. <br><br>If there is a new track: 2021-01-01T12:00:00, then the result will be:<br>1: 08:00 / 09:00<br>2: 10:00 / 12:00<br>If the track is 2021-01-01T07:00:00 instead, then the previous tracks are reordered to be consistent with concept of attendance pairs:<br>1: 07:00 / 08:00<br>2: 09:00 / 10:00
     * @param {AttendanceApiCreateTrackTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public createTrackTime(requestParameters: AttendanceApiCreateTrackTimeRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).createTrackTime(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns one attendance entry specified by  **attendanceId**.
     * @param {AttendanceApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public getById(requestParameters: AttendanceApiGetByIdRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).getById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns an array of objects. Every object contains an attendance category.
     * @param {AttendanceApiGetCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public getCategories(requestParameters: AttendanceApiGetCategoriesRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).getCategories(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a paginated list of expected time by user for a given date range.
     * @param {AttendanceApiGetExpectedTimeByUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public getExpectedTimeByUser(requestParameters: AttendanceApiGetExpectedTimeByUserRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).getExpectedTimeByUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns an array of objects with all the existing attendance entries within Kenjo for a maximum of 31 days, defined by the required params **from** and **to**. Every object contains an attendance entry.
     * @param {AttendanceApiGetListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public getList(requestParameters: AttendanceApiGetListRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).getList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint delete the attendance entry specified by **attendanceId**.
     * @param {AttendanceApiRemoveByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public removeById(requestParameters: AttendanceApiRemoveByIdRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).removeById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the attendance entry specified by **attendanceId**. Only the fields submitted in the body will be updated.
     * @param {AttendanceApiUpdateEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApiGenerated
     */
    public updateEntry(requestParameters: AttendanceApiUpdateEntryRequest, options?: AxiosRequestConfig) {
        return AttendanceApiFp(this.configuration).updateEntry(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
